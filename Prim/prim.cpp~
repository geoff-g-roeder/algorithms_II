#include <iostream>
#include <string>
#include <fstream>
#include <queue>
#include <vector>
#include <climits>
#include <cstdlib>
#include <set>


struct HeapNode {

  int key;
  int vertexNumber;

  HeapNode(int k, int vN):key(k),vertexNumber(vN) {}
  /*
  const int getKey( void ) {
    return key;
  }
  void setKey ( int newKey ) {
    key = newKey;
  }
  const int getVertexNumber( void ) {
    return vertexNumber;
  }
  void setVertexNumber( int newVN ) {
    vertexNumber = newVN;
  }*/
};

class MinHeapNodeComparator {
public:
  bool operator() (const HeapNode* lhs, const HeapNode* rhs) const {
    return lhs->key > rhs->key;
  }
};

typedef std::priority_queue<HeapNode*, std::vector<HeapNode*>, MinHeapNodeComparator> HeapNodePQ;

struct AdjListNode {
  int key; // For Prim
  int dest;
  int weight;

  struct AdjListNode* next;
  AdjListNode( int k, int d, int w, AdjListNode* n)
    :key(k),dest(d),weight(w),next(n) {};
    
};

struct AdjList {
  struct AdjListNode * head;
};

// REQUIRES: Graph uses 1-based convention for labelling nodes 1 to V
//           Graph number of nodes known beforehand (switch to vec otherwise)
struct Graph {

  int V;
  AdjList* verts;

  Graph(int V_in):V(V_in){
    verts = new AdjList[V];

    for (int i =0; i < V; i++)
      verts[i].head = NULL;
  }

  void add_edge(int s, int d, int w) {
    AdjListNode* new_node = new AdjListNode(INT_MAX, d, w, NULL);
    new_node->next = verts[s-1].head; // OVERCOME NODE NAME CONVENTION 1-INDEX
    verts[s-1].head = new_node;
    new_node = new AdjListNode(INT_MAX, s, w, NULL);
    new_node->next = verts[d-1].head;
    verts[d-1].head = new_node;
  }

  void print( void ) {
    for (int v = 0; v < V; v++) {
      AdjListNode* cursor = verts[v].head;
      std::cout << "\n Adjacency list of vertex " << v+1 << std::endl;
      while (cursor) {
	std::cout << "-->" << cursor->dest << "(" << cursor->weight << ")";
	cursor = cursor->next;
      }
      std::cout << std::endl;
    }
  }
};

int main ( void ) {

  // Algorithms II HW #1.3: Prim's algorithm
  std::ifstream read_file("edges.txt");
  std::string in_str;
  std::string first_line;
  std::getline(read_file,first_line);

  int num_nodes = atoi(first_line.substr(0,first_line.find(" ")).c_str());

  std::string num_edges = first_line.substr(first_line.find(" ")+1);

  Graph* G =  new Graph(num_nodes);

  while (std::getline(read_file, in_str)) {
    std::string s_val1 = in_str.substr(0,in_str.find(" "));
    std::string s_val2_temp = in_str.substr(s_val1.size() + 1);
    std::string s_val2 = s_val2_temp.substr(0,s_val2_temp.find(" "));
    std::string s_val3_temp = in_str.substr(s_val2.size() + s_val1.size() + 2);
    std::string s_val3 = s_val3_temp.substr(0, s_val3_temp.find(" "));
     
    /*   std::cout << "[" << std::stoi(s_val1) << " : " << s_val2 << " : "
	 << s_val3 << "]" << std::endl; */
    G->add_edge(std::atoi(s_val1.c_str()),std::atoi(s_val2.c_str()),std::atoi(s_val3.c_str()));
    
 }
  
    G->print();
    int V = G->V;

    int key[V];
    key[0] = 0;
    for(int k = 1; k < V; k++)
      key[k] = INT_MAX;

    int parent[V];
    for (int k = 0; k < V; k++)
      parent[k] = -1;
    HeapNodePQ heapNodeHeap;    
   
    std::set<int> PQMembership;
    for (int l = 1; l< 501; l++)
      PQMembership.insert(l);

    for (int i = 0; i < V; i++) {
      // key array is 0-indexed but graph nodes numbered from 1
      // i+1 is correct vertex number as function of i
      heapNodeHeap.push(new HeapNode(key[i],i+1));

    }
    std::cout << heapNodeHeap.top()->key << std::endl;			
   
    HeapNode * minHeapNode;
    while(!heapNodeHeap.empty())
      { 
	minHeapNode = heapNodeHeap.top();
	std::cout << "Top is now: " << minHeapNode->vertexNumber << std::endl;
	heapNodeHeap.pop();
	
	int u = minHeapNode->vertexNumber;
	PQMembership.erase(u);

	std::cout << u << " is no longer in PQ" << std::endl;
	int countEls = 0;
	for (int i =0; i < V; i++) {
	  if (key[i] != INT_MAX) {
	    countEls++;
	  }
	}
	std::cout << "currently " << countEls << " elts in key array" << std::endl;

	AdjListNode * listWalker = G->verts[u].head;
	while (listWalker != NULL) {
	  int v = listWalker->dest;
	  int vw = listWalker->weight;
	  if ((PQMembership.find(v) != PQMembership.end()) && vw < key[v]) {
	    key[v] = vw;
	    
	    parent[v] = u;
	    
	    
	    
	    // Rebuild PQ for elements still qualifying. I'm so sorry.
	    while (!heapNodeHeap.empty()) {
	      std::cout << "pop" << " ";
	      heapNodeHeap.pop();
	    }
	    for (int i = 0; (PQMembership.find(i) == PQMembership.end()) && (i < 500); i++)
	      
	      heapNodeHeap.push(new HeapNode(key[i],i+1));
	    
	    }
	  listWalker = listWalker->next;     
	}
	 
      

      }

}      

    
  

